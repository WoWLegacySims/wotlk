#!/usr/bin/python

import mysql.connector
from typing import List
import csv

# Generates go/ts files for assorted values read from the acore db

def GenIntIndexedDb(file : str):
    db = {}
    with open(file) as tsv:
        first = True
        for line in csv.reader(tsv, delimiter="\t"):
            if first:
                first = False
                continue
            db[int(line[0])] = line[1:]
    return db

BASE_DIR = ""

DIR_PATH = "assets/db_inputs/spells/"
SPELL = "Spell.csv"

GO_OUTPUT_PATH = "sim/core/"
TS_OUTPUT_PATH = "ui/core/"
SPELLDBC = GenIntIndexedDb(DIR_PATH + SPELL)

ElixirExcludes = "32767,32766,34537,8827"
ElixirAdditions = "9088"

FoodAdditions = {
    57301: 57294,
    57426: 57399,
    66486: 66623,
}
FoodIds = "24105, 17198, 724, 1082, 3728, 12215, 13928, 33004, 20452, 33024, 35563, 35565, 21023, 27651, 27655, 27657, 27658, 27659, 27663, 27667, 33867, 33825, 33872, 34754, 34755, 34756, 34758, 34769, 42994, 42995, 42996, 42998, 42999, 43000, 43015, 46399"

Off = {
    "Effect": 68,
    "EffectDie": 71,
    "EffectScaling": 74,
    "EffectBasePoints": 77,
    "EffectAura": 92,
    "EffectMiscValueA": 107,
    "EffectTriggerSpell": 113,
}

AuraEffect = {
    "damage": 13,
    "crit": 71,
    "resistance": 22,
    "stat" : 29,
    "regen": 85,
    "rating": 189,
    "health": 34,
    "attackpower": 99,
    "attackpowervs": 102,
    "penetration": 123,
    "hp5": 161,
    "periodic trigger": 23,
}

SchoolMask = {
    "Physical":1,
    "Holy":2,
    "Fire":4,
    "Nature":8,
    "Frost":16,
    "Shadow":32,
    "Arcane":64,
    "Magic":126,
}

Resistance = {
    1: "Armor",
    2: "HolyResistance",
    4: "FireResistance",
    8: "NatureResistance",
    16: "FrostResistance",
    32: "ShadowResistance",
    64: "ArcaneResistance",
}

Stat = {
    0: "Strength",
    1: "Agility",
    2: "Stamina",
    3: "Intellect",
    4: "Spirit",
}

Rating = {
  1: "Defense",
  2: "Dodge",
  3: "Parry",
  4: "Block",
  5: "MeleeHit",
  7: "SpellHit",
  8: "MeleeCrit",
  10: "SpellCrit",
  14: "Resilience",
  17: "MeleeHaste",
  19: "SpellHaste",
  23: "Expertise",
  24: "ArmorPenetration",
}

class Mixology:
    entry: int
    mod: float

class Aura:
    entry: int
    name: str
    spell: int
    level: int
    stats: List[str]

class Elixir(Aura):
    flag: int

def CleanName(name: str):
    remove = "()'-:"
    for c in remove:
        name = name.replace(c,"")
    return ''.join(name.split())

def WriteDef(flag: int):
    if flag == 1: return "enum BattleElixir {\nBattleElixirUnknown = 0;\n"
    if flag == 2: return "}\n\nenum GuardianElixir {\nGuardianElixirUnknown = 0;\n"
    if flag == 3: return "}\n\nenum Flask {\nFlaskUnknown = 0;\n"

def GenProto(elixirs: List[Elixir], food: List[Aura]):
    output = """
// **************************************
// AUTO GENERATED BY MISC_PARSER.PY
// **************************************
syntax = "proto3";
package proto;

option go_package = "./proto";

"""
    current = 0
    for el in elixirs:
        if el.flag != current:
            output += WriteDef(el.flag)
            current = el.flag

        output += f"{el.name} = {el.entry};\n"

    output += "}"

    output += "enum Food {\nFoodUnknown = 0;\n"
    for f in food:
        output += f"{f.name} = {f.entry};\n"

    output += "}"
    return output

def GenMixology(mixology: List[Mixology]):
    output = '''
package core

// **************************************
// AUTO GENERATED BY MISC_PARSER.PY
// **************************************

import (
	"github.com/WoWLegacySims/wotlk/sim/core/stats"
    "github.com/WoWLegacySims/wotlk/sim/core/proto"
)

type Consume struct {
	Stats stats.Stats
	Level int32
}

var Mixology = map[int32]float64{
'''
    for mix in mixology:
        output += f"{mix.entry}: {round(1+(mix.mod)/100,4)},\n"
    output += "}"
    return output


def GenStatAuras(auras: List[Aura], name:str):
    output = f"\nvar {name}s = map[proto.{name}]Consume{{\n"
    for aura in auras:
        spell = SPELLDBC[aura.spell]
        output += f"proto.{name}_{aura.name}: {{Level: {aura.level},\nStats: stats.Stats{{"
        aura.stats = []
        for eff in range(0,3):
            if (int(spell[Off["Effect"]+eff]) != 6):
                break

            effAura = int(spell[Off["EffectAura"]+eff])
            misc = int(spell[Off["EffectMiscValueA"]+eff])
            amount = int(spell[Off["EffectBasePoints"]+eff])+1

            if(effAura == AuraEffect["damage"]):
                if(misc == SchoolMask["Physical"]):
                    output += f"stats.AttackPower: {amount},stats.RangedAttackPower: {amount},"
                    aura.stats.append("AttackPower")
                    aura.stats.append("RangedAttackPower")

                elif (misc & SchoolMask["Magic"]):
                    output += f"stats.SpellPower: {amount},"
                    aura.stats.append("SpellPower")

            if(effAura == AuraEffect["stat"]):
                if(misc == -1):
                   for i in range(0,5):
                        output += f"stats.{Stat[i]}: {amount},"
                        aura.stats.append(Stat[i])
                else:
                   output += f"stats.{Stat[misc]}: {amount},"
                   aura.stats.append(Stat[misc])

            if(effAura == AuraEffect["resistance"]):
                for i in [1,4,8,16,32,64]:
                    if(i & misc):
                        output += f"stats.{Resistance[i]}: {amount},"
                        aura.stats.append(Resistance[i])

            if(effAura == AuraEffect["penetration"]):
                output += f"stats.SpellPenetration: {-amount},"
                aura.stats.append("SpellPenetration")

            if(effAura == AuraEffect["regen"]):
                if(misc == 0):
                    output += f"stats.MP5: {amount},"
                    aura.stats.append("MP5")

            if(effAura == AuraEffect["hp5"]):
                output += f"/*stats.HP5: {amount},*/"

            if(effAura == AuraEffect["health"]):
                if(misc == 0):
                    output += f"stats.Health: {amount},"
                    aura.stats.append("Health")

            if(effAura == AuraEffect["rating"]):
                for i, s in Rating.items():
                    if(misc & (1 << i)):
                        output += f"stats.{s}: {amount},"
                        aura.stats.append(s)

            if(effAura == AuraEffect["attackpower"] or effAura == AuraEffect["attackpowervs"]):
                output += f"stats.AttackPower: {amount}, stats.RangedAttackPower: {amount},"
                aura.stats.append("AttackPower")
                aura.stats.append("RangedAttackPower")

        output += "}},\n"
    output += "}"
    return output

def GenGOElixirs(elixirs: List[Elixir]):
    output = ""
    list = []
    for el in elixirs:
        if el.flag == 1:
            list.append(el)

    output += GenStatAuras(list,"BattleElixir")

    list = []
    for el in elixirs:
        if el.flag == 2:
            list.append(el)

    output += GenStatAuras(list,"GuardianElixir")

    list = []
    for el in elixirs:
        if el.flag == 3:
            list.append(el)

    output += GenStatAuras(list,"Flask")
    return output

def GenConsumableStatOption(consume: List[Aura], category: str):
    output = ""
    statoption = ""
    output += f"export const {category.upper()}_CONFIG = [\n"
    for con in consume:
        #output += f"export const {con.name} = {{actionId: ActionId.fromItemId({con.entry}), value: {category}.{con.name}}};\n"
        output += f"{{ config : {{actionId: ActionId.fromItemId({con.entry}), value: {category}.{con.name}}}, stats: ["
        for stat in con.stats:
            output += f"Stat.Stat{stat},"
        output += f"],level: {con.level}}},\n"

    output += f"] as ConsumableStatOption<{category}>[];\n"
    #output += f"export const {category.upper()}_CONFIG = [\n"
    #output += statoption
    #output += f"] as ConsumableStatOption<{category}>[];\n"
    return output


def GenTSElixirs(elixirs: List[Elixir]):
    output = ""
    list = []
    for el in elixirs:
        if el.flag == 1:
            list.append(el)

    output += GenConsumableStatOption(list,"BattleElixir")

    list = []
    for el in elixirs:
        if el.flag == 2:
            list.append(el)

    output += GenConsumableStatOption(list,"GuardianElixir")

    list = []
    for el in elixirs:
        if el.flag == 3:
            list.append(el)

    output += GenConsumableStatOption(list,"Flask")
    return output

def GenConsumableStatOptions(elixirs: List[Elixir], food: List[Aura]):
    output = """import {Stat} from "../../proto/common";
import {BattleElixir,Flask,Food,GuardianElixir} from '../../proto/consumes_gen.js'
import { ActionId } from "../../proto_utils/action_id";
import { ConsumableStatOption } from "./consumables.js";

"""
    output += GenTSElixirs(elixirs)
    output += GenConsumableStatOption(food,"Food")
    return output


if __name__ == "__main__":
    db = mysql.connector.connect(host="localhost", user="root", password="root", database="acore_world")

    cursor = db.cursor()
    cursor.execute("SELECT * FROM spell_mixology")
    results = cursor.fetchall()
    mixology = []
    for x in results:
        mix = Mixology()
        mix.entry = x[0]
        mix.mod = x[1]
        mixology.append(mix)

    cursor.execute(f"""SELECT entry ,name, spellid_1, RequiredLevel, special_flag
FROM item_template
JOIN spell_group ON spellid_1 = spell_group.spell_id
WHERE ((name LIKE "%flask %" OR name LIKE "%elixir%") AND spellid_1 > 0 AND NOT name like "%recipe%" AND NOT entry IN({ElixirExcludes}) AND special_flag <= 3) OR entry IN({ElixirAdditions})
ORDER BY special_flag ASC""")
    results = cursor.fetchall()
    elixirs = []
    for x in results:
        elixir = Elixir()
        elixir.entry = x[0]
        elixir.name = CleanName(x[1])
        elixir.spell = x[2]
        elixir.level = x[3]
        elixir.flag = x[4]
        elixirs.append(elixir)

    cursor.execute("SELECT spell_id FROM spell_group WHERE id = 1001")
    results = cursor.fetchall()
    foodSpells = []
    eatSpells = {}
    for x in results:
        foodSpells.append(int(x[0]))

    for id,spell in SPELLDBC.items():
        for eff in range(0,3):
            if(int(spell[Off["Effect"]+eff]) != 6):
                continue
            if(int(spell[Off["EffectAura"]+eff]) != AuraEffect["periodic trigger"]):
                continue
            for food in foodSpells:
                if (int(spell[Off["EffectTriggerSpell"]+eff]) == food):
                    eatSpells[str(id)] = food

    for f, s in FoodAdditions.items():
        eatSpells[str(f)] = s

    eatSpellKeys = ','.join(eatSpells.keys())

    cursor.execute(f"""SELECT entry ,name, spellid_1, RequiredLevel
FROM item_template
WHERE spellid_1 IN({eatSpellKeys}) AND entry IN({FoodIds})
UNION ALL
SELECT entry ,name, spellid_2, RequiredLevel
FROM item_template
WHERE spellid_2 IN({eatSpellKeys}) AND entry IN({FoodIds})
UNION ALL
SELECT entry ,name, spellid_3, RequiredLevel
FROM item_template
WHERE spellid_3 IN({eatSpellKeys}) AND entry IN({FoodIds})
""")
    results = cursor.fetchall()
    food = []
    for x in results:
        f = Aura()
        f.entry = x[0]
        f.name = CleanName(x[1])
        f.spell = eatSpells[str(x[2])]
        f.level = x[3]
        food.append(f)

    output = GenMixology(mixology)
    output += GenGOElixirs(elixirs)
    output += GenStatAuras(food, "Food")
    fname = BASE_DIR + GO_OUTPUT_PATH + "consumes_gen.go"
    print(f"Writing stats to: {fname}")
    f = open(fname, "w")
    f.write(output)
    f.close()

    output = GenProto(elixirs, food)
    fname = BASE_DIR + "proto/consumes_gen.proto"
    print(f"Writing proto to: {fname}")
    f = open(fname, "w")
    f.write(output)
    f.close()

    output = GenConsumableStatOptions(elixirs, food)
    fname = BASE_DIR + TS_OUTPUT_PATH + "components/inputs/consumes_gen.ts"
    print(f"Writing proto to: {fname}")
    f = open(fname, "w")
    f.write(output)
    f.close()
